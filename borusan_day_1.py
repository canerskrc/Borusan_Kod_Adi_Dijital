# -*- coding: utf-8 -*-
"""Borusan_Day_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zhr6-YQUhHPu79xamr_yc7nyGrrCZU9F
"""

report_date: str = "2025-09-02"
Daily_exchance_endpoint = "https://api.getplatedname/exchange"

#UPPER_SNAKE_CASE = DEĞİŞMEYECEK DEĞERİ İFADE EDER.

integer = tamsayı
double = ondalıklı sayı
boolean = mantıksal ifadeler ( true, false)
float = ondalıklı sayı
string = kelime ( karakter dizisi )

#tek satırda iki değişken ataması
call_success_rate, dropped_calls = 0.98, 42

#tuple

liste = ["caner", 28, 3.14]

liste[0]

conversion_A, conversion_B = ( 0.94,0.85)

_, longitude, latitude = ("abc123", 29.012, 41,856)

# _ ifadesi çöp alan oluşturur.

#star unpacking ( log parse )
ts, level, *message = [ "2025-09-02T10:22:06Z","WARN","High","latency","on","pod-7"]

8*2

22/7

22//7

from pathlib import Path

RAW_DIR = Path ("C://Downloads/data/raw") ; Curated_DIR = Path("data/curated")

import os
REGION = os.getenv("REGION", "eu-central-1")

#cwd = Bulunduğun klasörü gösterir. cwd = os.getcwd()
#os.mkdir() Yeni bir klasör oluşturur.

"""## Fonksiyonlar"""

def selam(isim="misafir"):
  print(f"Merhaba {isim}...")

def topla(a: int, b:int) -> int:
  return a+b

#*arg ve **kwargs

def siparis(*urunler, **detaylar):
  print("Ürünler", urunler)
  print("Detaylar", detaylar)

def saf_topla(a,b):
  return a+b

def ekle(liste, eleman):
  liste.append(eleman) # append = listeye yeni veri ekler.

#hata yönetimi

def sayiya_cevir(metin):
  try:
    return int(metin)
  except:
    return None

#generator ile akış yönetimi
#nums = [ 1,2,3,5,7,6,.....9999]
def only_even(nums: Iterable[int]):
  for n in nums:
    if n  % 2 == 0: # == eşit mi ?( % 2 ): bir sayının 2 ile bölümünden kalanı verir.
      yield n

#dekoratör ( ön işlem ve son işlem  yapısı )

def logla(fonk):
  def sarmal(*a, **k):
    print("Çalışıyor...")
    return fonk(*a,**k)
  return sarmal

# performans için veri yolunu I/O noktalarını minimumda tutun.
# Sık sık çağırılan bir fonksiyon varsa functools.lru_cache farydalı olur.

# Büyük listeleri kopyalamak yerine iterasyon ve dekoratör kullanımı faydalı olur.

from functools import wraps

def logged(func): # dekoratör fonksiyon haline gelir. İçerisine başka bir fonksiyon aldığı için.
  @wraps(func)
  def wrapper(*a,**kw):
    print(f"[CALL] {func.__name__} a={a} kw={kw}")
    #fonksiyon çağırıldığında önce log basar. örn: add(3,4) çağrısında şu yazılır.
    return func(*a,**kw) # asıl fonksiyonu çağırır.
  return wrapper # logged fonksiyonu süslenmiş haliyle ( wrapper ) geri döndürür.

  @logged
  def add(a,b): return a + b

def filtrele(musteriler, min_yas=None, max_yas=None):
  sonuc=[]
  for m in musteriler:
    yas = m.get("age")
    if yas is None:
      continue
    if min_yas is not None and yas < min_yas:
      continue
    if max_yas is not None and yas > max_yas:
      continue
    sonuc.append(m)
  return sonuc

def yas_kategorisi(yas: int) -> str:
  match yas:
    case _ if yas < 18:
      return "Çocuk"
    case _ if 18 <= yas <= 25:
      return "Genç"
    case _ if 26 <= yas <=35:
      return "Genç Yetişkin"
    case _ if 36 <= yas <= 45:
      return "Orta Yaş"
    case _ if 46 <= yas <= 60:
      return "Yaşlı"
    case _:
      return "Bilinmeyen"

from typing import Any, Iterable, Mapping, Sequence
def bucket_customers_by_age(
    customers : Iterable[Mapping[str, Any]], #Müşteri listesi( her müşteri bir sözlük)
    buckets : Sequence[tupple[int, int]] # = ( 18,25) şeklinde yaş aralıklarını işler
)