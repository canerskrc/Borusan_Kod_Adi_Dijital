# -*- coding: utf-8 -*-
"""Borusan_day_11_feature_engineering_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lSc__4NjwCGqDVJEaSrUvTV0e9uVpk5c

#Özellik Mühendisliği

- Gradyan Tabanlı Optimizasyonda ( SGD, Adam ) dengesiz adımlar büyük problemler yaratır. Bazı parametreler çok hızlı güncellenir. Bazıları da hiç öğrenemez.

- Düzenlileştirme adımında scale edilmemiş bir özellik olursa cezası adaletsiz olur.

- Mesafe Tabanlı Algoritmalarda ( Knn, SVM, K-means, PCA ) uzay geometrisi bozulur. Büyük aralıklar daha baskın hale gelir.

Adımlar:
- Ölçeklendirme ( Scaling)

- Normalizasyon

- Standartlaştırma

##Mutlak Maksimum Ölçeklendirme ( MaxAbs )

Çıktılar [-1,1] aralığındadır.

Sparse veriler( TF-IDF, bag of words ) geldiğinde en ideal teknik.

Outlier yüzünden çoğu continuos numeric future'da güvenilmez.

Silikon vadisinde RobustScaler + clipping veya quantile transform ile outlier'lar temizlendikten sonra uygulanır.
"""

from sklearn.preprocessing import MaxAbsScaler, StandardScaler, RobustScaler

import pandas as pd
import numpy as np

data = {
    "RPM": [800,1500,2000,2200,8000],
    "Engine_temp": [70,85,90,95,300],
    "Oil_pressure": [30,35,40,38,150]
}

df = pd.DataFrame(data)

def maxabs_scaler(X):
  X = X.astype(float)
  max_abs = np.abs(X).max(axis=0)
  return X / max_abs

df_maxabs = maxabs_scaler(df)
print("MaxAbs Scaler:\n", df_maxabs)

def standard_scaler(X: pd.DataFrame) -> pd.DataFrame:
  mean = X.mean(axis=0)
  std = X.std(axis=0)
  scaled = (X - mean) / std
  return scaled, mean, std

df_std, mean_val, std_val = standard_scaler(df)
print("Standard Scaling:\n", df_std, "\n")
print("Kullanılan mean değeri:\n",mean_val, "\n")
print("Kullanılan std değeri:\n",std_val, "\n")

def robust_scaler():
  median = X.median(axis=0)
  q1 = X.quantile(0.25)
  q3 = X.quantile(0.75)
  iqr = q3-q1
  scaled = (X - median ) / iqr
  return scaled, median, q1,q3, iqr
df_robust , med_val, q1_val, q3_val, iqr_val = robust_scaler(df)
print()